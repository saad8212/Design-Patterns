<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abstract Factory</title>
</head>
<body style="display:flex;align-items:center;justify-content:center;flex-direction: column;">
    <h2 style="width:80%">The Abstract Factory pattern allows us to produce families of related objects 
        without specifying concrete classes. It's useful in situations where we need to create objects
        that share only some properties and methods.The way it works is by presenting an abstract factory 
        the client interacts with. That abstract factory calls the corresponding concrete factory given the 
        corresponding logic. And that concrete factory is the one that returns the end object.Basically it 
        just adds an abstraction layer over the factory method pattern, so that we can create many different 
        types of objects, but still interact with a single factory function or class.
    </h2>
















<script>
    console.log("....Hi");
    class Car {
        constructor () {
            this.name = "Car"
            this.wheels = 4
        }
        turnOn = () => console.log("ChacabÃºm!!")
    }

    class Truck {
        constructor () {
            this.name = "Truck"
            this.wheels = 8
        }
        turnOn = () => console.log("RRRRRRRRUUUUUUUUUMMMMMMMMMM!!")
    }

    class Motorcycle {
        constructor () {
            this.name = "Motorcycle"
            this.wheels = 2
        }
        turnOn = () => console.log("sssssssssssssssssssssssssssssshhhhhhhhhhham!!")
    }

        // And and abstract factory that works as a single point of interaction for our clients
        // Given the type parameter it receives, it will call the corresponding concrete factory
    const vehicleFactory = {
        createVehicle: function (type) {
            switch (type) {
                case "car":
                    return new Car()
                case "truck":
                    return new Truck()
                case "motorcycle":
                    return new Motorcycle()
                default:
                    return null
            }
        }
    }

    const car = vehicleFactory.createVehicle("car") // Car { turnOn: [Function: turnOn], name: 'Car', wheels: 4 }
    const truck = vehicleFactory.createVehicle("truck") // Truck { turnOn: [Function: turnOn], name: 'Truck', wheels: 8 }
    const motorcycle = vehicleFactory.createVehicle("motorcycle") // Motorcycle { turnOn: [Function: turnOn], name: 'Motorcycle', wheels: 2 }
    console.log(car);


        // Another Procedure
    function Employee(name) {
        this.name = name;
        this.say = function () {
            console.log("I am employee " + name);
        };
    }

    function EmployeeFactory() {
        this.create = function (name) {
            return new Employee(name);
        };
    }

    function Vendor(name) {
        this.name = name;
        this.say = function () {
            console.log("I am vendor " + name);
        };
    }

    function VendorFactory() {
        this.create = function (name) {
            return new Vendor(name);
        };
    }

    function run() {
        var persons = [];
        var employeeFactory = new EmployeeFactory();
        var vendorFactory = new VendorFactory();
        persons.push(employeeFactory.create("Joan DiSilva"));
        persons.push(employeeFactory.create("Tim O'Neill"));
        persons.push(vendorFactory.create("Gerald Watson"));
        persons.push(vendorFactory.create("Nicole McNight"));
        for (var i = 0, len = persons.length; i < len; i++) {
            persons[i].say();
        }
        console.log(persons);
    }
    run();
</script>
</body>
</html>