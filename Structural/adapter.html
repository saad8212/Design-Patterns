<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adapter Pattern</title>
</head>
<body style="display: flex;justify-content:center; flex-direction: column; align-items: center;">
    <h2 style="width: 60%;">Adapter Pattern</h2><br>
    <h3 style="width:60%">
        An Adapter Pattern says that just "converts the interface of a class into another interface that a client wants".
        The adapter pattern convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldnâ€™t otherwise because of incompatible interfaces.
        The Adapter allows two objects with incompatible interfaces to interact with each other.
        Let's say, for example, that your application consults an API that returns XML and sends that information to another API to process that information. But the processing API expects JSON. You can't send the information as it's received since both interfaces are incompatible. You need to adapt it first. <br><br>ðŸ˜‰

        We can visualize the same concept with an even simpler example. Say we have an array of cities and a function that returns the greatest number of habitants any of those cities have. The number of habitants in our array is in millions, but we have a new city to add that has its habitants without the million conversion:
    </h3>



    <script>
        // Our array of cities
        const citiesHabitantsInMillions = [
            { city: "London", habitants: 8.9 },
            { city: "Rome", habitants: 2.8 },
            { city: "New york", habitants: 8.8 },
            { city: "Paris", habitants: 2.1 },
        ] 

        // The new city we want to add
        const BuenosAires = {
            city: "Buenos Aires",
            habitants: 3100000
        }

        // Our adapter function takes our city and converts the habitants property to the same format all the other cities have
        const toMillionsAdapter = city => { 
            city.habitants = parseFloat((city.habitants/1000000).toFixed(1)) 
        }

        toMillionsAdapter(BuenosAires)

        // We add the new city to the array
        citiesHabitantsInMillions.push(BuenosAires)

        // And this function returns the largest habitants number
        const MostHabitantsInMillions = () => {
            return Math.max(...citiesHabitantsInMillions.map(city => city.habitants))
        }

        console.log(MostHabitantsInMillions()) // 8.9
    </script>
</body>
</html>