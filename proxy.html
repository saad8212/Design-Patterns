<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proxy Pattern</title>
</head>
<body style="display: flex;justify-content:center; flex-direction: column; align-items: center;">
    <h2 style="width: 60%;">Proxy Pattern</h2><br>
    <h3 style="width:60%">
        Proxy means a stand-in for someone else. Instead of speaking to that person directly, you'll speak to the proxy person who will represent the person you were trying to reach. The same happens in JavaScript: instead of interacting with the target object directly, we'll interact with the Proxy object.
        <br/><br/>
        In object-oriented programming, objects do the work they advertise through their interface (properties and methods). Clients of these objects expect this work to be done quickly and efficiently. However, there are situations where an object is severely constrained and cannot live up to its responsibility. Typically this occurs when there is a dependency on a remote resource (resulting in network latency) or when an object takes a long time to load.
        <br/><br/>
        In situations like these you apply the Proxy pattern and create a proxy object that ‘stands in’ for the original object. The Proxy forwards the request to a target object. The interface of the Proxy object is the same as the original object and clients may not even be aware they are dealing with a proxy rather than the real object
        <br/>
        Proxies are a powerful way to add control over the behavior of an object. A proxy can have various use-cases: it can help with validation, formatting, notifications, or debugging.
    </h3>


<script>
    // We Will add new API which returns some responses
    function NewApiFunction  ()  {
        this.getValue = function(coin){
            console.log("Calling external API");
            switch(coin){
                case "bitcoin1":
                    return "35000";
                case "bitcoin2":
                    return "45000";
                case "bitcoin3":
                    return "65000";
                case "bitcoin4":
                    return "23000";
                case "bitcoin5":
                    return "28000";
                case "bitcoin6":
                    return "39000";
            }

        }
    }
    const api = new NewApiFunction();

    console.log(api.getValue("bitcoin6"),api.getValue("bitcoin4"), api.getValue("bitcoin2"));
    // Now we know this will slow down as the number of requests increases so we will make an proxy for this
    // and saves this in a cache memory

    function ApiFunctionProxy () {
        this.cache = {};
        this.apiFunc = new NewApiFunction();
        this.getValue = function(coin){
            if(this.cache[coin] == null){
                this.cache[coin] = this.apiFunc.getValue(coin);
            }
            return this.cache[coin];
        }    
    }
    //we will use seconde function working same as new 
    const Proxy = new ApiFunctionProxy();
    console.log(Proxy.getValue("bitcoin5"));
</script>

    
</body>
</html>